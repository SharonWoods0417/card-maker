# 开发问题记录

> **版本 v1.1 — 2024-12-26**  
> **🎯 MVP完成度：90% | 当前重点：PDF导出真实实现**  
> **什么时候记录**：Cursor尝试修改3次都没成功时就记录
> **为什么记录**：避免重复踩坑，积累解决经验

## 🚀 **当前开发状态**

### **✅ 已完成功能（90%）**
- 用户输入、智能补全、卡片预览、API控制系统全部完成
- 所有核心架构稳定运行，代码质量良好

### **🔥 当前最重要任务**
- **PDF导出真实实现**：替换ExportSection.tsx中的模拟代码
- **技术方案**：使用`@react-pdf/renderer`生成真实PDF文件
- **完成标准**：用户能下载可打印的PDF文件

### **📋 开发建议**
- 优先解决PDF导出问题，其他功能可暂缓
- 遇到PDF相关问题立即记录到本文档
- 完成PDF功能后，MVP即可投入使用

---

## 📝 **简单模板**

```
## 问题 #001 - [简要描述问题]

**时间**：2024-12-26
**状态**：❌ 未解决 | ✅ 已解决

### 🐛 **问题是什么**
[描述遇到的具体问题]

### 💻 **关键错误信息**
[只记录最重要的1-2行错误，不要整段复制]

**示例格式：**
- 报错：`Cannot find module './components/CardPreview'`
- 位置：`src/App.tsx 第15行`
- 或者：`TypeError: Cannot read property 'map' of undefined`

### 🔧 **Cursor试过的方案**
1. 方案一：xxx - 失败了，因为xxx
2. 方案二：xxx - 失败了，因为xxx  
3. 方案三：xxx - 失败了，因为xxx

### 🎯 **解决的关键**
[问题的根本原因是什么]

### 🔍 **调试方法**
[用什么方法找到问题的]

### ✅ **最终解决方案**
[最后怎么解决的，详细步骤]

### 💡 **学到什么**
[下次怎么避免这个问题]

---
```

---

## 📋 **问题列表**

### ❌ **未解决的问题**
*还没有未解决的问题*

### ✅ **已解决的问题**
*还没有已解决的问题*

---

## 🛠️ **常见问题速查**

### **错误信息提取技巧**
- **找关键词**：看错误信息里的 `Error:`、`Cannot`、`undefined` 等关键词
- **找文件位置**：看 `at xxx.tsx:15:20` 这样的位置信息
- **忽略堆栈**：长长的调用堆栈可以不记录，只要核心错误
- **记录格式**：`错误类型 + 出错位置` 就够了

**提取示例：**
```
❌ 原始错误（很长）：
Error: Cannot find module './components/CardPreview'
    at Object.<anonymous> (/Users/xxx/card-maker/src/App.tsx:5:1)
    at Module._compile (node:internal/modules/cjs/loader.js:1108:14)
    at Module._extensions..js (node:internal/modules/cjs/loader.js:1137:10)
    ...还有20行堆栈信息

✅ 提取后（简洁）：
- 报错：Cannot find module './components/CardPreview'
- 位置：src/App.tsx 第5行
```

### **报错相关**
- **类型错误**：检查 `src/types/index.ts` 文件
- **导入错误**：检查文件路径是否正确
- **编译错误**：看看 `tsconfig.json` 配置

### **界面相关**
- **样式不显示**：检查 `tailwind.config.js`
- **组件不渲染**：看看 React Hook 用法
- **热更新失效**：重启 `npm run dev`

### **调试模式相关** 🆕
- **调试按钮不显示**：检查 `.env.local` 中的 `VITE_DEBUG_MODE` 设置
- **环境变量不生效**：确保变量名以 `VITE_` 开头，重启开发服务器
- **API统计不更新**：检查 `apiUsageControl.ts` 服务是否正常运行
- **控制台无调试信息**：确认浏览器开发者工具已打开Console面板

### **OpenRouter API相关** 🆕
- **API调用失败**：检查 `VITE_OPENROUTER_API_KEY` 配置是否正确
- **模型不支持**：确认 `VITE_OPENROUTER_MODEL` 设置的模型名称有效
- **请求头错误**：确保HTTP-Referer和X-Title头部设置正确
- **成本异常**：查看API统计界面的费用计算是否合理

### **调试技巧**

#### **基础调试**
1. **看控制台**：F12 打开开发者工具，点击 Console 看错误信息
2. **看终端**：npm run dev 的命令行输出，红色的就是错误
3. **一步步试**：先注释掉一部分代码，看问题是否消失
4. **对比代码**：和之前能用的版本对比，看改了什么

#### **前端界面调试**
5. **检查元素**：右键点击页面元素 → "检查"，看HTML结构
6. **调试样式**：在Elements面板右侧可以实时修改CSS样式
7. **查看组件**：安装React DevTools，可以看组件的props和state
8. **手机预览**：F12后点击手机图标，测试移动端效果

#### **网络和数据调试**
9. **查看请求**：F12 → Network面板，看API请求是否成功
10. **模拟网络**：Network面板可以模拟慢网络或断网
11. **查看数据**：用 `console.log(变量名)` 在控制台打印数据
12. **断点调试**：在代码里写 `debugger;` 会暂停执行

#### **性能和错误调试**
13. **查看加载**：Network面板看哪些文件加载慢
14. **内存检查**：Performance面板录制页面操作，找卡顿原因
15. **错误追踪**：看控制台的错误堆栈，找到出错的具体行数
16. **热更新问题**：删除 `node_modules` 重新 `npm install`

#### **移动端调试**
17. **真机调试**：手机连WiFi访问电脑的IP地址
18. **触摸调试**：开发者工具里可以模拟手指触摸
19. **屏幕适配**：切换不同设备尺寸测试响应式

#### **调试模式专用技巧** 🆕
20. **查看调试状态**：打开Console查看"🔧 调试模式状态"信息
21. **测试API限制**：使用"重置统计"按钮重新测试限制机制
22. **清除缓存测试**：使用"清空缓存"按钮强制重新调用API
23. **环境变量检测**：在Console中输入 `import.meta.env` 查看所有环境变量
24. **API统计验证**：观察API统计面板的实时更新情况
25. **OpenRouter测试**：确认当前使用的模型名称在API统计界面正确显示
26. **多模型切换**：修改 `VITE_OPENROUTER_MODEL` 测试不同AI模型

#### **其他实用技巧**
27. **快速定位**：Ctrl+Shift+C 快速选择页面元素
28. **重新加载**：Ctrl+F5 强制刷新，清除缓存
29. **代码格式化**：Shift+Alt+F 自动整理代码格式
30. **查找替换**：Ctrl+H 批量替换代码
31. **多光标编辑**：按住Alt点击多个位置，同时编辑

---

## 🎛️ **调试模式详解（小白必学）**

> **这是什么**：调试模式就像给软件加了一个"专业模式开关"，让开发者能看到更多技术信息，普通用户界面更简洁。

### 🔧 **环境变量控制法（超实用）**

#### **什么是环境变量？**
环境变量就像是给程序设置的"开关"，不同环境可以有不同设置：
- **开发环境**：你在电脑上写代码测试时（localhost:3002）
- **生产环境**：发布给学生老师使用时（真实网站）

#### **实际操作步骤**

**1. 查看当前配置**
```bash
# 在终端运行，查看调试模式状态
grep VITE_DEBUG_MODE .env.local
```

**2. 开启调试模式**
```bash
# 方法1：直接修改文件
echo "VITE_DEBUG_MODE=true" > .env.local

# 方法2：手动编辑.env.local文件，改为：
VITE_DEBUG_MODE=true
```

**3. 关闭调试模式**
```bash
# 方法1：直接修改文件  
echo "VITE_DEBUG_MODE=false" > .env.local

# 方法2：手动编辑.env.local文件，改为：
VITE_DEBUG_MODE=false
```

**4. 重启服务器让配置生效**
```bash
# 按Ctrl+C停止服务器，然后重新启动
npm run dev
```

#### **效果对比**

**开启调试模式时（VITE_DEBUG_MODE=true）**：
- ✅ 显示红色"关闭调试"按钮
- ✅ 点击后显示技术参数面板
- ✅ 控制台显示详细日志信息
- ✅ 可以看到字体大小、颜色代码等

**关闭调试模式时（VITE_DEBUG_MODE=false）**：
- ❌ 调试按钮完全不显示
- ✅ 界面简洁，适合最终用户
- ✅ 性能更好

### 🎯 **为什么这种方法这么好用？**

#### **1. 一键切换**
不用改代码，只改配置文件就能控制功能显示

#### **2. 环境隔离**
- 开发时：显示所有调试信息，方便排查问题
- 发布时：隐藏技术细节，用户体验更好

#### **3. 团队协作友好**
- 每个开发者可以有自己的 `.env.local` 配置
- 不会影响其他人的开发环境

#### **4. 符合行业标准**
- 这是专业软件开发的标准做法
- 大公司都是这样管理不同环境的

### 🔍 **环境变量命名规则**

#### **Vite项目规则**
```bash
# ✅ 正确：以VITE_开头，前端可以访问
VITE_DEBUG_MODE=true
VITE_API_KEY=your_key_here
VITE_APP_NAME=card-maker

# ❌ 错误：不以VITE_开头，前端访问不到
DEBUG_MODE=true
API_KEY=your_key_here
```

#### **常用环境变量示例**
```bash
# 调试控制
VITE_DEBUG_MODE=true

# API配置
VITE_OPENROUTER_API_KEY=your_openrouter_key
VITE_PEXELS_API_KEY=your_pexels_key

# 应用配置
VITE_APP_TITLE=英语单词卡片生成器
VITE_APP_VERSION=1.0.0
```

### 🛠️ **环境变量调试技巧**

#### **1. 在浏览器控制台查看所有环境变量**
```javascript
// 按F12，在Console中输入：
console.log('所有环境变量:', import.meta.env);

// 查看特定变量：
console.log('调试模式:', import.meta.env.VITE_DEBUG_MODE);
```

#### **2. 在代码中使用环境变量**
```typescript
// 获取环境变量
const isDebugMode = import.meta.env.VITE_DEBUG_MODE === 'true';
const apiKey = import.meta.env.VITE_API_KEY;

// 条件渲染
{isDebugMode && <DebugPanel />}
```

#### **3. 环境变量不生效的排查**
1. **检查变量名**：必须以 `VITE_` 开头
2. **检查文件名**：必须是 `.env.local`（注意前面的点）
3. **重启服务器**：修改后必须重启 `npm run dev`
4. **检查语法**：`变量名=值`，等号两边不要有空格

### 📱 **实际应用场景**

#### **场景1：开发阶段**
```bash
# .env.local 配置
VITE_DEBUG_MODE=true
VITE_API_MOCK=true
VITE_LOG_LEVEL=verbose
```
- 显示所有调试信息
- 使用模拟API数据
- 详细日志输出

#### **场景2：测试阶段**
```bash
# .env.local 配置
VITE_DEBUG_MODE=false
VITE_API_MOCK=false
VITE_LOG_LEVEL=error
```
- 隐藏调试信息
- 使用真实API
- 只显示错误日志

#### **场景3：生产发布**
```bash
# .env.production 配置
VITE_DEBUG_MODE=false
VITE_API_MOCK=false
VITE_LOG_LEVEL=none
```
- 完全隐藏调试功能
- 生产环境API
- 不输出日志

### 🎓 **进阶技巧**

#### **1. 多环境配置文件**
```bash
.env.local          # 本地开发环境
.env.development    # 开发环境
.env.production     # 生产环境
.env.test          # 测试环境
```

#### **2. 条件调试组件**
```typescript
// 只在调试模式下显示的组件
const DebugInfo = () => {
  if (import.meta.env.VITE_DEBUG_MODE !== 'true') {
    return null;
  }
  
  return (
    <div className="debug-panel">
      <h3>调试信息</h3>
      <p>当前环境: {import.meta.env.MODE}</p>
      <p>API地址: {import.meta.env.VITE_API_URL}</p>
    </div>
  );
};
```

#### **3. 动态调试开关**
```typescript
// 可以在运行时切换的调试模式
const [runtimeDebug, setRuntimeDebug] = useState(false);

// 结合环境变量和运行时状态
const isDebugActive = import.meta.env.VITE_DEBUG_MODE === 'true' || runtimeDebug;
```

### ⚠️ **注意事项**

#### **安全提醒**
1. **不要把敏感信息放在环境变量里**（如密码）
2. **API密钥要妥善保管**，不要提交到Git
3. **生产环境务必关闭调试模式**

#### **性能提醒**
1. **调试模式会影响性能**，发布时要关闭
2. **过多的console.log会拖慢页面**
3. **大型调试面板会占用内存**

### 💡 **学习总结**

这种环境变量控制调试模式的方法之所以好用，是因为：

1. **简单直接**：改一个配置文件就能控制功能
2. **专业标准**：这是行业通用做法
3. **灵活可控**：不同环境可以有不同配置
4. **团队友好**：每个人可以有自己的设置
5. **维护方便**：不需要修改代码逻辑

掌握了这个方法，你就学会了现代前端开发的一个重要技能！

---

## 🔧 **其他超实用调试方法（小白进阶）**

### 📱 **浏览器开发者工具（F12神器）**

#### **1. Console控制台调试**
```javascript
// 基础调试输出
console.log('普通信息:', 变量名);
console.warn('警告信息:', 变量名);
console.error('错误信息:', 变量名);

// 分组显示
console.group('API调用');
console.log('请求地址:', url);
console.log('请求参数:', params);
console.groupEnd();

// 表格显示数据
console.table([{name: 'apple', count: 5}, {name: 'book', count: 3}]);

// 计时器
console.time('API请求耗时');
// ... API调用代码
console.timeEnd('API请求耗时');
```

#### **2. Elements元素检查**
- **右键 → 检查**：直接定位到HTML元素
- **实时修改CSS**：在Styles面板修改样式立即生效
- **查看盒模型**：看元素的margin、padding、border
- **响应式测试**：点击手机图标测试不同屏幕尺寸

#### **3. Network网络监控**
```bash
# 查看API请求
1. 打开F12 → Network标签
2. 刷新页面或触发API调用
3. 点击具体请求查看：
   - Headers: 请求头信息
   - Response: 服务器返回数据
   - Preview: 格式化的响应数据
```

#### **4. Sources源码调试**
```javascript
// 在代码中设置断点
debugger; // 程序会在这里暂停

// 或者在Sources面板点击行号设置断点
// 然后可以：
// - 单步执行（F10）
// - 进入函数（F11）
// - 查看变量值
// - 修改变量值
```

### 🎯 **React特有调试技巧**

#### **1. React DevTools扩展**
```bash
# 安装React DevTools浏览器扩展
# Chrome: 搜索"React Developer Tools"
# 安装后F12会多出Components和Profiler标签

# 使用方法：
1. Components标签：查看组件树和props/state
2. 选中组件可以在Console中用$r访问
3. 可以实时修改props和state的值
```

#### **2. 组件内调试**
```typescript
// 在组件中打印状态
const [words, setWords] = useState([]);

// 调试hook
useEffect(() => {
  console.log('words状态变化:', words);
}, [words]);

// 调试props
const MyComponent = ({ data }) => {
  console.log('收到的props:', data);
  return <div>...</div>;
};
```

### 💡 **终端调试技巧**

#### **1. 开发服务器日志**
```bash
# 启动开发服务器时会显示：
npm run dev

# 关注这些信息：
✅ 正常：VITE ready in 67ms
❌ 错误：[vite] Internal server error
⚠️ 警告：[vite] hmr update failed
```

#### **2. 构建错误排查**
```bash
# 检查TypeScript错误
npx tsc --noEmit

# 检查ESLint错误
npx eslint src

# 尝试构建
npm run build
```

#### **3. 依赖问题排查**
```bash
# 清除依赖重新安装
rm -rf node_modules package-lock.json
npm install

# 检查依赖版本冲突
npm ls
```

### 🔍 **API调试专门技巧**

#### **1. API请求调试**
```typescript
// 在API调用前后加日志
export async function getWordEntry(word: string) {
  console.log('🔍 开始查询单词:', word);
  
  try {
    const result = await fetch('/api/word/' + word);
    console.log('✅ API响应:', result);
    return result;
  } catch (error) {
    console.error('❌ API调用失败:', error);
    throw error;
  }
}
```

#### **2. 环境变量API调试**
```typescript
// 检查API配置
console.log('API配置检查:', {
  baseUrl: import.meta.env.VITE_API_BASE_URL,
  apiKey: import.meta.env.VITE_API_KEY ? '已配置' : '未配置',
  debugMode: import.meta.env.VITE_DEBUG_MODE
});
```

### 🎨 **样式调试技巧**

#### **1. CSS问题排查**
```css
/* 临时给元素加边框，查看布局 */
.debug-border {
  border: 1px solid red !important;
}

/* 查看元素占用空间 */
.debug-background {
  background-color: rgba(255, 0, 0, 0.1) !important;
}
```

#### **2. Tailwind CSS调试**
```bash
# 检查Tailwind配置
npx tailwindcss --help

# 查看生成的CSS
npm run build
# 然后查看dist/assets/目录下的CSS文件
```

### 📝 **调试最佳实践**

#### **1. 分层调试法**
```typescript
// 第1层：输入验证
console.log('1. 输入参数:', { word, options });

// 第2层：处理过程
console.log('2. 处理中间结果:', intermediateResult);

// 第3层：输出结果
console.log('3. 最终结果:', finalResult);
```

#### **2. 条件调试法**
```typescript
// 只在特定条件下输出调试信息
const DEBUG = import.meta.env.VITE_DEBUG_MODE === 'true';

if (DEBUG) {
  console.log('调试信息:', data);
}

// 或者封装成函数
const debugLog = (message: string, data?: any) => {
  if (DEBUG) {
    console.log(`🔧 ${message}`, data);
  }
};
```

#### **3. 错误边界调试**
```typescript
// React错误边界组件
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    console.error('React错误边界捕获:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>出错了，请查看控制台</h1>;
    }
    return this.props.children;
  }
}
```

### 🚀 **性能调试技巧**

#### **1. 渲染性能**
```typescript
// 检查组件重新渲染次数
const MyComponent = () => {
  const renderCount = useRef(0);
  renderCount.current += 1;
  
  console.log(`组件渲染次数: ${renderCount.current}`);
  
  return <div>...</div>;
};
```

#### **2. 内存使用监控**
```javascript
// 在Console中查看内存使用
console.log('内存使用:', {
  usedJSHeapSize: performance.memory.usedJSHeapSize,
  totalJSHeapSize: performance.memory.totalJSHeapSize
});
```

### 📚 **调试工具推荐**

#### **1. 浏览器扩展**
- **React DevTools**：React组件调试
- **Redux DevTools**：状态管理调试
- **Vue DevTools**：Vue项目调试
- **Lighthouse**：性能分析

#### **2. VS Code扩展**
- **Debugger for Chrome**：在VS Code中调试
- **Console Ninja**：增强的console.log
- **Error Lens**：实时显示错误信息

#### **3. 在线工具**
- **JSONFormatter**：格式化API响应
- **RegExr**：正则表达式测试
- **Can I Use**：检查浏览器兼容性

### 🎯 **调试思维训练**

#### **问题定位三步法**
1. **复现问题**：确保能稳定重现错误
2. **缩小范围**：通过注释代码找到出错位置
3. **深入分析**：查看变量值、API响应、控制台错误

#### **调试心态**
- **保持冷静**：错误是正常的，不要慌张
- **系统性思考**：从输入到输出，一步步检查
- **记录过程**：把解决方案记录下来，下次遇到同样问题就能快速解决

### 💪 **小白到高手的调试进阶路径**

#### **初级阶段（你现在这里）**
- ✅ 学会使用console.log
- ✅ 掌握F12开发者工具基础用法
- ✅ 理解环境变量控制

#### **中级阶段**
- 🎯 熟练使用断点调试
- 🎯 掌握Network面板分析API
- 🎯 学会React DevTools

#### **高级阶段**
- 🚀 性能分析和优化
- 🚀 复杂错误边界处理
- 🚀 自动化测试和调试

记住：**调试能力是程序员最重要的技能之一**，多练习就会越来越熟练！

---

> **💡 提示**：遇到问题别慌，先看看这里有没有类似的，没有就按模板记录下来！ 

## 🧹 代码质量优化记录

### 📅 2024年12月 - 最后一次全面代码检查与修复

#### 🔍 问题发现与分析
在MVP核心功能开发完成后，进行了全面的代码质量检查，发现以下问题：

**🔴 严重问题：**
1. **PDF导出功能模拟实现** - 这是阻碍MVP完成的关键问题
   - 位置：`src/components/ExportSection.tsx`
   - 问题：`const blob = new Blob(['PDF content would be here'], { type: 'application/pdf' });`
   - 影响：用户无法获得真实PDF文件，产品无法真正使用

**🟡 代码质量问题：**
1. **重复代码** - `formatWordForStorage`函数在多个文件中重复定义
2. **调试信息过多** - 生产环境包含大量console.log语句
3. **专有名词列表重复** - 在多处硬编码相同的专有名词列表

#### 🛠️ 修复方案与实施

**1. 代码重构 - 消除重复代码**
```typescript
// 修复前：在3个文件中重复定义formatWordForStorage
// - src/components/InputSection.tsx
// - src/components/CardPreview.tsx  
// - src/utils/sampleData.ts

// 修复后：统一到工具模块
// src/utils/dictionary.ts
export function formatWordForStorage(word: string): string {
  const properNouns = [
    'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday',
    'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 
    'September', 'October', 'November', 'December', 
    'China', 'America', 'English', 'Chinese', 'American'
  ];
  
  const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
  return properNouns.includes(capitalizedWord) ? capitalizedWord : word.toLowerCase();
}
```

**2. 调试信息优化 - 环境感知的日志系统**
```typescript
// 修复前：所有环境都输出调试信息
console.log(`🔍 获取单词条目: ${word}`);

// 修复后：仅开发环境输出调试信息
const isDebug = import.meta.env.DEV;
if (isDebug) console.log(`🔍 获取单词条目: ${word}`);
```

**3. 代码组织优化**
- 将调试工具函数统一归类到专门的调试区域
- 添加详细的JSDoc注释说明函数用途
- 改进错误处理的降级策略

#### 📊 修复结果验证

**构建测试：**
```bash
npm run build
# ✅ 构建成功，无TypeScript错误
# ✅ 无ESLint警告
# ✅ 文件大小优化：189.37 kB (gzip: 59.58 kB)
```

**代码质量提升：**
- ✅ 消除了3处重复代码
- ✅ 减少了生产环境的调试输出
- ✅ 统一了专有名词处理逻辑
- ✅ 改进了错误处理机制

#### 🎯 当前项目状态
经过本次代码质量优化，项目完成度从90%提升到**95%**：

**✅ 已完成的功能（95%）：**
- 完整UI界面和组件架构
- OpenRouter API集成和成本控制
- 本地词典构建工具模块
- Oxford Phonics拼读拆分系统
- 调试模式和实时监控
- API使用控制和缓存系统
- 代码质量优化（无重复代码，环境感知日志）

**❌ 待完成的功能（5%）：**
- React-PDF真实实现（唯一阻碍MVP完成的功能）

#### 💡 开发经验总结

**最佳实践：**
1. **定期代码检查** - 在功能开发完成后进行全面代码审查
2. **环境感知开发** - 使用`import.meta.env.DEV`控制调试功能
3. **工具函数提取** - 及时发现并消除重复代码
4. **降级策略设计** - 确保错误情况下的用户体验

**小白友好提示：**
- 🔍 使用`npm run build`检查代码质量
- 🧹 定期清理console语句，保持生产代码整洁
- 📦 将通用函数提取到工具模块，避免重复
- 🎯 关注项目完成度，优先解决阻碍MVP的关键问题

---

## 🔧 核心功能问题

### 🚨 问题1：PDF导出功能未真实实现（最高优先级）

**问题描述：**
ExportSection组件中的PDF导出功能只是模拟实现，用户无法获得真实的PDF文件。

**问题代码：**
```typescript
// src/components/ExportSection.tsx
const blob = new Blob(['PDF content would be here'], { type: 'application/pdf' });
```

**影响评估：**
- 🔴 **严重程度：关键** - 这是MVP的最后一块拼图
- 📊 **完成度影响：** 90% → 100%
- 👥 **用户影响：** 无法真正使用产品核心功能

**解决方案：**
实现React-PDF库集成，生成真实的可打印PDF文件（任务1.5）

**优先级：** 🔥 **最高优先级** - 完成后项目即可发布MVP

---